/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Argent
 */
export interface Argent {
    /**
     * 
     * @type {string}
     * @memberof Argent
     */
    'nom'?: string;
    /**
     * 
     * @type {string}
     * @memberof Argent
     */
    't'?: string;
    /**
     * 
     * @type {number}
     * @memberof Argent
     */
    'valeurComptable'?: number;
    /**
     * 
     * @type {Devise}
     * @memberof Argent
     */
    'devise'?: Devise;
    /**
     * 
     * @type {string}
     * @memberof Argent
     */
    'dateOuverture'?: string;
    /**
     * 
     * @type {Set<FluxArgent>}
     * @memberof Argent
     */
    'fluxArgents'?: Set<FluxArgent>;
}
/**
 * 
 * @export
 * @interface Devise
 */
export interface Devise {
    /**
     * 
     * @type {string}
     * @memberof Devise
     */
    'nom'?: string;
    /**
     * 
     * @type {number}
     * @memberof Devise
     */
    'valeurEnAriary'?: number;
    /**
     * 
     * @type {string}
     * @memberof Devise
     */
    't'?: string;
    /**
     * 
     * @type {number}
     * @memberof Devise
     */
    'tauxDappr√©ciationAnnuel'?: number;
}
/**
 * 
 * @export
 * @interface FluxArgent
 */
export interface FluxArgent {
    /**
     * 
     * @type {string}
     * @memberof FluxArgent
     */
    'nom'?: string;
    /**
     * 
     * @type {string}
     * @memberof FluxArgent
     */
    't'?: string;
    /**
     * 
     * @type {number}
     * @memberof FluxArgent
     */
    'valeurComptable'?: number;
    /**
     * 
     * @type {Devise}
     * @memberof FluxArgent
     */
    'devise'?: Devise;
    /**
     * 
     * @type {Argent}
     * @memberof FluxArgent
     */
    'argent'?: Argent;
    /**
     * 
     * @type {string}
     * @memberof FluxArgent
     */
    'debut'?: string;
    /**
     * 
     * @type {string}
     * @memberof FluxArgent
     */
    'fin'?: string;
    /**
     * 
     * @type {number}
     * @memberof FluxArgent
     */
    'fluxMensuel'?: number;
    /**
     * 
     * @type {number}
     * @memberof FluxArgent
     */
    'dateOperation'?: number;
}
/**
 * 
 * @export
 * @interface Materiel
 */
export interface Materiel {
    /**
     * 
     * @type {string}
     * @memberof Materiel
     */
    'nom'?: string;
    /**
     * 
     * @type {string}
     * @memberof Materiel
     */
    't'?: string;
    /**
     * 
     * @type {number}
     * @memberof Materiel
     */
    'valeurComptable'?: number;
    /**
     * 
     * @type {Devise}
     * @memberof Materiel
     */
    'devise'?: Devise;
}
/**
 * 
 * @export
 * @interface Patrimoine
 */
export interface Patrimoine {
    /**
     * 
     * @type {string}
     * @memberof Patrimoine
     */
    'nom'?: string;
    /**
     * 
     * @type {Personne}
     * @memberof Patrimoine
     */
    'possesseur'?: Personne;
    /**
     * 
     * @type {string}
     * @memberof Patrimoine
     */
    't'?: string;
    /**
     * 
     * @type {Set<Possession>}
     * @memberof Patrimoine
     */
    'possessions'?: Set<Possession>;
    /**
     * 
     * @type {number}
     * @memberof Patrimoine
     */
    'valeurComptable'?: number;
}
/**
 * 
 * @export
 * @interface PatrimoineBody
 */
export interface PatrimoineBody {
    /**
     * 
     * @type {string}
     * @memberof PatrimoineBody
     */
    'nom'?: string;
    /**
     * 
     * @type {Personne}
     * @memberof PatrimoineBody
     */
    'possesseur'?: Personne;
    /**
     * 
     * @type {string}
     * @memberof PatrimoineBody
     */
    't'?: string;
    /**
     * 
     * @type {Set<Possession>}
     * @memberof PatrimoineBody
     */
    'possessions'?: Set<Possession>;
}
/**
 * 
 * @export
 * @interface Personne
 */
export interface Personne {
    /**
     * 
     * @type {string}
     * @memberof Personne
     */
    'nom'?: string;
}
/**
 * 
 * @export
 * @interface Possession
 */
export interface Possession {
    /**
     * 
     * @type {string}
     * @memberof Possession
     */
    'nom'?: string;
    /**
     * 
     * @type {string}
     * @memberof Possession
     */
    't'?: string;
    /**
     * 
     * @type {number}
     * @memberof Possession
     */
    'valeurComptable'?: number;
    /**
     * 
     * @type {Devise}
     * @memberof Possession
     */
    'devise'?: Devise;
}

/**
 * HealthBucketControllerApi - axios parameter creator
 * @export
 */
export const HealthBucketControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileCanBeUploadedThenSigned: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/bucket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthBucketControllerApi - functional programming interface
 * @export
 */
export const HealthBucketControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthBucketControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileCanBeUploadedThenSigned(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileCanBeUploadedThenSigned(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthBucketControllerApi.fileCanBeUploadedThenSigned']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthBucketControllerApi - factory interface
 * @export
 */
export const HealthBucketControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthBucketControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileCanBeUploadedThenSigned(options?: any): AxiosPromise<string> {
            return localVarFp.fileCanBeUploadedThenSigned(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthBucketControllerApi - object-oriented interface
 * @export
 * @class HealthBucketControllerApi
 * @extends {BaseAPI}
 */
export class HealthBucketControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthBucketControllerApi
     */
    public fileCanBeUploadedThenSigned(options?: RawAxiosRequestConfig) {
        return HealthBucketControllerApiFp(this.configuration).fileCanBeUploadedThenSigned(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthEmailControllerApi - axios parameter creator
 * @export
 */
export const HealthEmailControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmails: async (to: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'to' is not null or undefined
            assertParamExists('sendEmails', 'to', to)
            const localVarPath = `/health/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthEmailControllerApi - functional programming interface
 * @export
 */
export const HealthEmailControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthEmailControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmails(to: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmails(to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthEmailControllerApi.sendEmails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthEmailControllerApi - factory interface
 * @export
 */
export const HealthEmailControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthEmailControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} to 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmails(to: string, options?: any): AxiosPromise<string> {
            return localVarFp.sendEmails(to, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthEmailControllerApi - object-oriented interface
 * @export
 * @class HealthEmailControllerApi
 * @extends {BaseAPI}
 */
export class HealthEmailControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} to 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthEmailControllerApi
     */
    public sendEmails(to: string, options?: RawAxiosRequestConfig) {
        return HealthEmailControllerApiFp(this.configuration).sendEmails(to, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PatrimoineEndpointApi - axios parameter creator
 * @export
 */
export const PatrimoineEndpointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PatrimoineBody} patrimoineBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpdate: async (patrimoineBody: PatrimoineBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'patrimoineBody' is not null or undefined
            assertParamExists('createUpdate', 'patrimoineBody', patrimoineBody)
            const localVarPath = `/patrimoines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patrimoineBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {Set<Argent>} argent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateArgent: async (nomPatrimoine: string, argent: Set<Argent>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('crupdateArgent', 'nomPatrimoine', nomPatrimoine)
            // verify required parameter 'argent' is not null or undefined
            assertParamExists('crupdateArgent', 'argent', argent)
            const localVarPath = `/patrimoines/{nom_patrimoine}/possessions/argent`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(argent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {Set<FluxArgent>} fluxArgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateFluxArgent: async (nomPatrimoine: string, fluxArgent: Set<FluxArgent>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('crupdateFluxArgent', 'nomPatrimoine', nomPatrimoine)
            // verify required parameter 'fluxArgent' is not null or undefined
            assertParamExists('crupdateFluxArgent', 'fluxArgent', fluxArgent)
            const localVarPath = `/patrimoines/{nom_patrimoine}/possessions/fluxArgent`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fluxArgent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {Set<Materiel>} materiel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateMateriel: async (nomPatrimoine: string, materiel: Set<Materiel>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('crupdateMateriel', 'nomPatrimoine', nomPatrimoine)
            // verify required parameter 'materiel' is not null or undefined
            assertParamExists('crupdateMateriel', 'materiel', materiel)
            const localVarPath = `/patrimoines/{nom_patrimoine}/possessions/materiel`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(materiel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/patrimoines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPossessionByPatrimoine: async (nomPatrimoine: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('getAllPossessionByPatrimoine', 'nomPatrimoine', nomPatrimoine)
            const localVarPath = `/patrimoines/{nom_patrimoine}/possessions`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineByName: async (nomPatrimoine: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('getPatrimoineByName', 'nomPatrimoine', nomPatrimoine)
            const localVarPath = `/patrimoines/{nom_patrimoine}`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {string} debut 
         * @param {string} fin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineFuture: async (nomPatrimoine: string, debut: string, fin: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nomPatrimoine' is not null or undefined
            assertParamExists('getPatrimoineFuture', 'nomPatrimoine', nomPatrimoine)
            // verify required parameter 'debut' is not null or undefined
            assertParamExists('getPatrimoineFuture', 'debut', debut)
            // verify required parameter 'fin' is not null or undefined
            assertParamExists('getPatrimoineFuture', 'fin', fin)
            const localVarPath = `/patrimoines/{nom_patrimoine}/graphe`
                .replace(`{${"nom_patrimoine"}}`, encodeURIComponent(String(nomPatrimoine)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (debut !== undefined) {
                localVarQueryParameter['debut'] = (debut as any instanceof Date) ?
                    (debut as any).toISOString().substring(0,10) :
                    debut;
            }

            if (fin !== undefined) {
                localVarQueryParameter['fin'] = (fin as any instanceof Date) ?
                    (fin as any).toISOString().substring(0,10) :
                    fin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatrimoineEndpointApi - functional programming interface
 * @export
 */
export const PatrimoineEndpointApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PatrimoineEndpointApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PatrimoineBody} patrimoineBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUpdate(patrimoineBody: PatrimoineBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Patrimoine>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUpdate(patrimoineBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineEndpointApi.createUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {Set<Argent>} argent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateArgent(nomPatrimoine: string, argent: Set<Argent>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<Possession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateArgent(nomPatrimoine, argent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineEndpointApi.crupdateArgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {Set<FluxArgent>} fluxArgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateFluxArgent(nomPatrimoine: string, fluxArgent: Set<FluxArgent>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<Possession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateFluxArgent(nomPatrimoine, fluxArgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineEndpointApi.crupdateFluxArgent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {Set<Materiel>} materiel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async crupdateMateriel(nomPatrimoine: string, materiel: Set<Materiel>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<Possession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.crupdateMateriel(nomPatrimoine, materiel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineEndpointApi.crupdateMateriel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Patrimoine>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineEndpointApi.getAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPossessionByPatrimoine(nomPatrimoine: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<Possession>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPossessionByPatrimoine(nomPatrimoine, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineEndpointApi.getAllPossessionByPatrimoine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatrimoineByName(nomPatrimoine: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Patrimoine>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatrimoineByName(nomPatrimoine, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineEndpointApi.getPatrimoineByName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {string} debut 
         * @param {string} fin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPatrimoineFuture(nomPatrimoine: string, debut: string, fin: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPatrimoineFuture(nomPatrimoine, debut, fin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatrimoineEndpointApi.getPatrimoineFuture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PatrimoineEndpointApi - factory interface
 * @export
 */
export const PatrimoineEndpointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PatrimoineEndpointApiFp(configuration)
    return {
        /**
         * 
         * @param {PatrimoineBody} patrimoineBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpdate(patrimoineBody: PatrimoineBody, options?: any): AxiosPromise<Patrimoine> {
            return localVarFp.createUpdate(patrimoineBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {Set<Argent>} argent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateArgent(nomPatrimoine: string, argent: Set<Argent>, options?: any): AxiosPromise<Set<Possession>> {
            return localVarFp.crupdateArgent(nomPatrimoine, argent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {Set<FluxArgent>} fluxArgent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateFluxArgent(nomPatrimoine: string, fluxArgent: Set<FluxArgent>, options?: any): AxiosPromise<Set<Possession>> {
            return localVarFp.crupdateFluxArgent(nomPatrimoine, fluxArgent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {Set<Materiel>} materiel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        crupdateMateriel(nomPatrimoine: string, materiel: Set<Materiel>, options?: any): AxiosPromise<Set<Possession>> {
            return localVarFp.crupdateMateriel(nomPatrimoine, materiel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(options?: any): AxiosPromise<Array<Patrimoine>> {
            return localVarFp.getAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPossessionByPatrimoine(nomPatrimoine: string, options?: any): AxiosPromise<Set<Possession>> {
            return localVarFp.getAllPossessionByPatrimoine(nomPatrimoine, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineByName(nomPatrimoine: string, options?: any): AxiosPromise<Patrimoine> {
            return localVarFp.getPatrimoineByName(nomPatrimoine, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} nomPatrimoine 
         * @param {string} debut 
         * @param {string} fin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPatrimoineFuture(nomPatrimoine: string, debut: string, fin: string, options?: any): AxiosPromise<File> {
            return localVarFp.getPatrimoineFuture(nomPatrimoine, debut, fin, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PatrimoineEndpointApi - object-oriented interface
 * @export
 * @class PatrimoineEndpointApi
 * @extends {BaseAPI}
 */
export class PatrimoineEndpointApi extends BaseAPI {
    /**
     * 
     * @param {PatrimoineBody} patrimoineBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineEndpointApi
     */
    public createUpdate(patrimoineBody: PatrimoineBody, options?: RawAxiosRequestConfig) {
        return PatrimoineEndpointApiFp(this.configuration).createUpdate(patrimoineBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} nomPatrimoine 
     * @param {Set<Argent>} argent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineEndpointApi
     */
    public crupdateArgent(nomPatrimoine: string, argent: Set<Argent>, options?: RawAxiosRequestConfig) {
        return PatrimoineEndpointApiFp(this.configuration).crupdateArgent(nomPatrimoine, argent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} nomPatrimoine 
     * @param {Set<FluxArgent>} fluxArgent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineEndpointApi
     */
    public crupdateFluxArgent(nomPatrimoine: string, fluxArgent: Set<FluxArgent>, options?: RawAxiosRequestConfig) {
        return PatrimoineEndpointApiFp(this.configuration).crupdateFluxArgent(nomPatrimoine, fluxArgent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} nomPatrimoine 
     * @param {Set<Materiel>} materiel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineEndpointApi
     */
    public crupdateMateriel(nomPatrimoine: string, materiel: Set<Materiel>, options?: RawAxiosRequestConfig) {
        return PatrimoineEndpointApiFp(this.configuration).crupdateMateriel(nomPatrimoine, materiel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineEndpointApi
     */
    public getAll(options?: RawAxiosRequestConfig) {
        return PatrimoineEndpointApiFp(this.configuration).getAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} nomPatrimoine 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineEndpointApi
     */
    public getAllPossessionByPatrimoine(nomPatrimoine: string, options?: RawAxiosRequestConfig) {
        return PatrimoineEndpointApiFp(this.configuration).getAllPossessionByPatrimoine(nomPatrimoine, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} nomPatrimoine 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineEndpointApi
     */
    public getPatrimoineByName(nomPatrimoine: string, options?: RawAxiosRequestConfig) {
        return PatrimoineEndpointApiFp(this.configuration).getPatrimoineByName(nomPatrimoine, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} nomPatrimoine 
     * @param {string} debut 
     * @param {string} fin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatrimoineEndpointApi
     */
    public getPatrimoineFuture(nomPatrimoine: string, debut: string, fin: string, options?: RawAxiosRequestConfig) {
        return PatrimoineEndpointApiFp(this.configuration).getPatrimoineFuture(nomPatrimoine, debut, fin, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PingControllerApi - axios parameter creator
 * @export
 */
export const PingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PingControllerApi - functional programming interface
 * @export
 */
export const PingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PingControllerApi.ping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PingControllerApi - factory interface
 * @export
 */
export const PingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(options?: any): AxiosPromise<string> {
            return localVarFp.ping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PingControllerApi - object-oriented interface
 * @export
 * @class PingControllerApi
 * @extends {BaseAPI}
 */
export class PingControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PingControllerApi
     */
    public ping(options?: RawAxiosRequestConfig) {
        return PingControllerApiFp(this.configuration).ping(options).then((request) => request(this.axios, this.basePath));
    }
}



